1. prj21.c (single-thread)
(1) 알고리즘도

메모리 할당 및 초기화:
count_circle 배열을 사용하여 전체 점의 수와 원 안에 포함된 점의 수를 저장.
이 배열은 모든 스레드가 해당 배열에 접근하여 최종 결과를 집계할 수 있도록 동적 메모리 할당을 이용 하였으며(heap에 저장), 초기 값은 0으로 설정.

무작위 점 생성:
rand_r 함수를 사용하여 단위 정사각형 내에서 무작위로 점을 생성.
각 점의 x, y 좌표는 [0, 1) 범위 내의 무작위 실수임.

원 안에 포함되는 점 확인:
점이 단위 원 안에 포함되는지 여부를 확인하기 위해 x^2 + y^2 ≤ 1 조건을 사용.
이 조건을 만족하는 점의 수를 카운트.

π 값 계산:
원 안에 포함된 점의 수와 전체 점의 수의 비율을 사용하여 π 값을 근사 계산.
π ≈ 4 * (원 안의 점의 수 / 전체 점의 수)

(2) 프로그램 수행시간
time ./prj21 실행 결과 화면은 다음과 같음.
1) 1000000(백 만) 실행 시
real    0m0.024s
user    0m0.024s
sys     0m0.000s
2) 10000000(천 만)
real    0m0.225s
user    0m0.224s
sys     0m0.000s
3) 100000000(1억 번)
real    0m2.265s
user    0m2.264s
sys     0m0.000s

2. prj22.c (multi-thread)

(1) 알고리즘도
초기화:
4개의 스레드(메인 스레드 포함)에서 계산한 결과를 집계할 배열인 count_circle 배열을 동적 할당 및 초기화.
세마포어를 초기화하여 여러 스레드가 공유 자원에 동시에 접근하지 않도록 함.

스레드 생성 및 실행:
각 스레드는 multi_thread 함수를 실행하여 독립적으로 점을 생성하고 원 안에 포함되는 점의 수를 계산.
각 스레드는 로컬 변수를 사용하여 점을 생성하고, 원 안에 포함되는 점의 수를 계산.
각 스레드는 계산이 완료된 후, 세마포어를 사용하여 공유 데이터 (count_circle)에 안전하게 접근하여 결과를 병합.
--> 현 코드 작성 전, 다음 코드와 같이 for문 내부에서 세마포어를 이용하였으며, 지역변수를 for문 내부에서 이용한 후 결과를 집계하는 것이 아닌, 공유 데이터(args)에 "직접 접근"하여 값 갱신을 시도 하였음.
    그러나 이러한 코드 사용 시, 반복적인 세마포어를 통한 데이터 갱신으로 인해 성능 저하 문제가 발생하였음.
    구체적으로는 time command 실행 시, 싱글 스레드보다 실행시간이 더 오래 걸림을 발견.
    따라서 각 스레드 내부적으로는 지역변수를 통해 동작하도록 하고, 모든 연산 이후 갱신 과정에서만 세마포어를 이용하도록 코드를 변경함. 

    - 문제 코드:
    for(i = 0; i <250000; i++) {
            sem_wait(&sem);
            x = (double)rand_r(&seed)/(double)RAND_MAX;
            y = (double)rand_r(&seed)/(double)RAND_MAX;
            args[0]++; //count
            if((x*x) + (y*y) <= 1){
                args[1]++; //circle
            }
            sem_post(&sem);
        }

점 생성 및 확인 (각 스레드 내에서):
무작위로 점을 생성.
각 점이 원 안에 포함되는지 확인.
로컬 변수에 결과 저장.

결과 병합 (각 스레드 내에서):
세마포어를 사용하여 공유 데이터(count_circle)에 결과 병합.

메인 스레드 작업:
메인 스레드도 동일한 작업을 수행.

π 값 계산:
모든 스레드의 결과를 병합한 후, π 값을 계산하여 출력.

(2) 프로그램 수행시간
time ./prj22 실행 결과 화면은 다음과 같음.
1) 1000000(백 만) 실행 시
real    0m0.008s
user    0m0.026s
sys     0m0.000s
2) 10000000(천 만)
real    0m0.084s
user    0m0.283s
sys     0m0.004s
3) 100000000(1억 번)
real    0m0.600s
user    0m2.366s
sys     0m0.004s

3. 멀티 스레드와 싱글 스레드에 대한 실행 시간 고찰
1-(2), 2-(2)에서 싱글 스레드와 멀티 스레드의 실행시간 결과를 정리하면:

(1) 실제 경과 시간 (real) 비교
백만 번 실행: 멀티스레드가 싱글스레드보다 약 3배 빠름.
천만 번 실행: 멀티스레드가 싱글스레드보다 약 2.7배 빠름.
1억 번 실행: 멀티스레드가 싱글스레드보다 약 3.8배 빠름.
--> 실제 경과 시간에서 멀티스레드 방식이 싱글스레드 방식보다 일관되게 빠르다는 점을 확인할 수 있음. 이는 병렬 처리로 인해 작업을 나누어 수행하는 멀티스레드의 이점이 나타난 결과임.

(2) 사용자 모드 CPU 시간 (user) 비교
백만 번 실행: 멀티스레드가 더 많은 사용자 모드 CPU 시간을 사용.
천만 번 실행: 멀티스레드가 더 많은 사용자 모드 CPU 시간을 사용.
1억 번 실행: 멀티스레드가 더 많은 사용자 모드 CPU 시간을 사용.
--> 멀티스레드는 여러 스레드가 동시에 작업을 수행하기 때문에 사용자 모드 CPU 시간의 총합이 더 크게 나타나는 것으로, 각 스레드가 독립적으로 작업을 처리하기 때문에 발생하는 현상이며, 단일 스레드를 사용하는 싱글 스레드보다 크게 나오는 것은 일반적.

(3) 시스템 모드 CPU 시간 (sys) 비교
시스템 모드 CPU 시간은 거의 차이가 없음.
--> 시스템 모드 CPU 시간은 두 방식 모두 거의 차이가 없는데, 이는 두 방식 모두 시스템 호출을 자주 사용하지 않기 때문으로 보임.

(4) 결론
멀티스레드 방식은 대규모 연산에서 실제 경과 시간을 단축하는 데 매우 효과적임. 그러나 사용자 모드 CPU 시간을 더 많이 사용하며, 스레드 관리 오버헤드가 발생할 수 있음. 반면, 싱글스레드 방식은 사용자 모드 CPU 시간이 적고, 스레드 관리 오버헤드가 없지만, 대규모 연산에서 실행 시간이 더 길어질 수 있음.
따라서 멀티스레드와 싱글스레드 방식의 장단점을 잘 이해하고, 작업의 특성에 맞게 적절한 방식을 선택하는 것이 중요함. 병렬 처리의 이점을 최대한 활용하기 위해서는 적절한 스레드 수를 선택하고, 스레드 간의 동기화 오버헤드를 최소화 할 수 있는 방법 고민이 필요 할 것.